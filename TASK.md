

3、了解MITRE ATT&CK等威胁框架，了解Windows/Linux/MacOS系统常见的安全攻击技术和工具；
4、对常见的安全产品有一定的了解，例如终端EDR、WAF、NTA、HIDS等；
1、针对最新的关键软件与系统漏洞，分析漏洞原理与利用方式；
2、发布漏洞预警，组织应急响应，参与漏洞复盘；


工作职责： 1.负责系统内各类固件/二进制文件的逆向分析与攻击验证，并提出加固措施和整改建议。 
2.具有对ARM、ELF、STM32、D2000V等固件5年以上逆向分析与攻击经验。

负责二进制情报攻防分析，拥有PE逆向、C2远控、免杀、攻防相关经验
1.研究最新的 Android/iOS/web 端/小程序端攻防技术，结合业务提供前瞻性的应对措施；
2.研究常见爬虫/反爬手法，分析其技术原理及防范方案；
3.跟踪业界安全动态，掌握黑灰产的最新变化，制定检测和管控方案； 
任职要求 1.本科及以上学历，至少熟练掌握 Java/Python/Go/JS 等一种编程语言；
2.熟悉 js 逆向，熟悉 web 常用反爬技术及主流爬虫框架； 
3.熟悉 app 逆向、掌握常用的抓包、反编译、hook 等技术原理和框架应用；
4.熟悉 Android 系统架构及 Android NDK 开发，熟悉 x86 和 ARM 汇编，熟练使用 IDA、GDB 等分析调试工具； 
5.加分项：具备移动端安全项目经验者优先

- [ ] 爬虫
- [ ] **漏洞挖掘
- [ ] 病毒分析
- [ ] PWN
- [ ] WEB
- [ ] 服务器
- [x] bindiff
- [ ] 流量分析
- [ ] 




- 岗位描述
    
    用前沿安全技术守护腾讯旗下所有创新产品和服务，保障亿万用户、企业及创新业务发展。 1、负责跟进研究业界顶尖网络安全攻防技术，结合业务需求进行落地，保持关键安全技术竞争力优势； 2、负责为通信与社交、数字内容、金融科技、工具软件等产品及服务定制安全方案，进行反入侵、反攻击、反劫持和审计等系统工具开发运营和优化； 3、负责安全风险评估与安全方案规划设计及落地，负责安全事件应急响应，分析跟踪事件，定位问题并制定解决方案，进行数据生命周期安全建设，梳理安全风险及推进治理。
    
- 岗位要求
    
    1、专业不限，有技术洞察力，对安全技术有狂热的追求，对新技术有热忱，有意愿在安全领域长期保持专注和投入； 2、熟悉漏洞挖掘、网络安全攻防技术，了解常见黑客攻击手法； 3、熟练使用C/C++语言，熟悉Python/Java/PHP/Go等至少一种程序开发语言； 4、对数据库、操作系统、网络原理等计算机学科基础知识有较好储备。
    
- 加分项或注意事项
    
    1、拥有实际软件逆向、漏洞分析利用或对抗方案开发的经验； 2、拥有大数据安全风控、红蓝对抗、主机安全、流量安全等项目或实习经验； 3、拥有安全渗透测试、安全威胁分析和应急响应处置经验。



SQL注入[教程](https://www.runoob.com/sql/sql-injection.html#:~:text=SQL%20%E6%B3%A8%E5%85%A5%EF%BC%88SQL%20Injection%EF%BC%89%E6%98%AF%E4%B8%80%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB%E6%89%8B%E6%AE%B5%EF%BC%8C%E6%94%BB%E5%87%BB%E8%80%85%E9%80%9A%E8%BF%87%E5%9C%A8%E8%BE%93%E5%85%A5%E5%AD%97%E6%AE%B5%E6%88%96%E8%AF%B7%E6%B1%82%E4%B8%AD%E6%B3%A8%E5%85%A5%E6%81%B6%E6%84%8F%E7%9A%84%20SQL%20%E8%AF%AD%E5%8F%A5%EF%BC%8C%E6%93%8D%E6%8E%A7%E6%95%B0%E6%8D%AE%E5%BA%93%E6%89%A7%E8%A1%8C%E6%84%8F%E5%9B%BE%E4%B9%8B%E5%A4%96%E7%9A%84%E6%93%8D%E4%BD%9C%E3%80%82,%E8%BE%93%E5%85%A5%E9%AA%8C%E8%AF%81%E4%B8%8D%E8%B6%B3%EF%BC%9A%E5%BD%93Web%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%B2%A1%E6%9C%89%E6%AD%A3%E7%A1%AE%E9%AA%8C%E8%AF%81%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5%E6%97%B6%EF%BC%8C%E6%94%BB%E5%87%BB%E8%80%85%E5%8F%AF%E4%BB%A5%E5%9C%A8%E8%BE%93%E5%85%A5%E5%AD%97%E6%AE%B5%E4%B8%AD%E6%8F%92%E5%85%A5SQL%E4%BB%A3%E7%A0%81%E3%80%82%20%E6%8B%BC%E6%8E%A5SQL%E8%AF%AD%E5%8F%A5%EF%BC%9A%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%90%8E%E7%AB%AF%E9%80%9A%E5%B8%B8%E5%B0%86%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5%E4%B8%8ESQL%E6%9F%A5%E8%AF%A2%E6%8B%BC%E6%8E%A5%E5%9C%A8%E4%B8%80%E8%B5%B7%EF%BC%8C%E5%BD%A2%E6%88%90%E5%AE%8C%E6%95%B4%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E3%80%82%20%E6%89%A7%E8%A1%8C%E6%81%B6%E6%84%8FSQL%EF%BC%9A%E5%A6%82%E6%9E%9C%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%B2%A1%E6%9C%89%E5%AF%B9%E8%BE%93%E5%85%A5%E8%BF%9B%E8%A1%8C%E9%80%82%E5%BD%93%E7%9A%84%E6%B8%85%E7%90%86%E6%88%96%E8%BD%AC%E4%B9%89%EF%BC%8C%E6%81%B6%E6%84%8FSQL%E4%BB%A3%E7%A0%81%E5%B0%86%E8%A2%AB%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%89%A7%E8%A1%8C%E3%80%82%20%E6%95%B0%E6%8D%AE%E6%B3%84%E9%9C%B2%E6%88%96%E7%A0%B4%E5%9D%8F%EF%BC%9A%E6%94%BB%E5%87%BB%E8%80%85%E5%8F%AF%E4%BB%A5%E5%88%A9%E7%94%A8SQL%E6%B3%A8%E5%85%A5%E6%9D%A5%E6%9F%A5%E8%AF%A2%E3%80%81%E4%BF%AE%E6%94%B9%E6%88%96%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%8C%E6%88%96%E8%80%85%E6%89%A7%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%B3%BB%E7%BB%9F%E5%91%BD%E4%BB%A4%E3%80%82%20%E5%BD%93%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E7%BD%91%E7%AB%99%E6%97%B6%EF%BC%8C%E9%80%9A%E5%B8%B8%E4%BC%9A%E8%BE%93%E5%85%A5%E7%94%A8%E6%88%B7%E5%90%8D%E5%92%8C%E5%AF%86%E7%A0%81%E3%80%82)

放置于Form表单或者请求参数中
绕过检测，获取敏感数据，触发数据库错误
盲注，布尔型，时间型

XSS跨站脚本攻击
反射：点击带有js脚本的链接
存储：存储于服务器，访问者触发


CSRF跨站请求伪造

DNS劫持

JSON劫持

**House of Botcake** 是一种针对 ​**glibc 2.29 及以上版本**的堆利用技术，主要用于绕过 ​**tcache** 中的 ​**double free 检测机制**，从而实现任意内存读写或代码执行

### ​**核心原理**

1. ​**绕过 tcache key 检测**
    
    - 在 glibc 2.29+ 中，tcache 引入了 `key` 字段（指向所属的 tcache 结构体），用于检测 double free。直接对同一 chunk 多次 free 会被拦截

    - ​**House of Botcake** 通过以下步骤绕过检测：
        1. ​**填满 tcache bin**：先释放 7 个同大小的 chunk 填满 tcache。
        2. ​**释放到 unsorted bin**：继续释放两个相邻的 chunk（如 chunk A 和 B），它们会合并进入 unsorted bin，此时不会设置 `key` 字段。
        3. ​**触发 double free**：从 tcache 中申请一个 chunk 腾出空间，再释放之前合并到 unsorted bin 的 chunk A，此时 chunk A 同时存在于 tcache 和 unsorted bin 中，形成 double free

2. ​**利用合并机制控制指针**
    
    - 通过堆块合并（unsorted bin）和重新分配，可以篡改 tcache 的 `next` 指针，最终实现 ​**任意地址分配**​（如修改 `__free_hook` 为 `system` 地址）






xposed
- **Hook机制**：通过劫持Android系统的 ​**Zygote进程**​（应用孵化器），在运行时拦截并修改Java方法的调用逻辑


- ​**模块化设计**：用户安装的Xposed模块以插件形式注入系统，按需修改特定功能（如界面、权限等），无需重新编译APK
	非侵入式修改，保留APK完整性


脚本编写：初始化，hook设置，数据处理

利用：
1. **ptrace 系统调用**
2. **访问** **`/proc`** **文件系统**：每个进程的各种信息（如内存映射、寄存器状态等）
3. **修改进程地址空间**



过程：
frida的动态库注入
拦截函数调用
访问进程内存
修改目标函数的入口地址，使其跳转到 Frida 的处理代码。
修改目标进程的堆栈和寄存器来执行 Hook 逻辑。

1.java.perform
2.java.use(包名)

3.Interceptor.attach

**动态插桩**：在目标程序运行时注入代码，无需修改源码或重新编译
​**Hook 能力**：拦截函数调用、修改参数/返回值、监控内存访问等-


smali
.class 类名
.field private a:Z 布尔类型私有变量a
.method 方法
.locals 2 表示方法里面有两个寄存器
.parameter 方法参数
.param p1, "haha" 方法里面有一个参数p1，它的值为"haha"
.prologue 方法开始
|boolean|Z|
|byte|B|
|short|S|
|char|C|
|int|I|
|long|J|
|float|F|
|double|D|
|void|V|

l Dex文件反编译后的文件，得到Smali代码，可以用于分析代码、分析逻辑，知道别人软件的这个功能是怎么实现的。

l Dex文件还可以反编译为JAR包，JAR包就是JAVA代码。

l 为什么用Smali代码不用JAVA代码分析，就是因为JAVA代码混淆比较严重，主要混淆是“函数名”，“类名”，“变量”，“包名”。

#Android系统架构
1. Linux内核层
	1. 硬件驱动
	2. 进程管理
	3. 内存管理
	4. 安全机制
	5. 电源管理
2. 硬件抽象层HAL
	6. 硬件提供接口
3. 系统运行时库（lib） Android Runtime
4. 应用java框架层
5. 应用层





基于模型的fuzzing 
向目标程序提供非预期随机的异常数据，触发潜在的漏洞

发现内存错误，释放后使用，空指针解引用
发现逻辑缺陷，认证绕过，条件竞争
验证健壮性，处理异常输入的能力

peach fuzzer
pit文件提供数据模型，状态模型
http版本号fuzzing

v2签名块
将apk文件中的其他部分按照1mb大小分块获取摘要

v3 新添一个attr块


apk打包
1. 资源预编译
2. 代码编译与转换，生成.class字节码，再转化为.dex文件
3. apk打包与对齐
4. 签名与发布
反编译
5. apktool解包，获取smali代码，资源文件，manifest
6. dex2jar将dex转化为.jar，用jadx查看
7. 资源分析


破解：
1.smali代码篡改
2.资源替换
3.xposed/frida 动态注入
4.内存修改
5.签名绕过



防御：动态加载：
应用分为loader和payload两部分，运行loader解密payload动态加载
破解：payload需要释放到文件系统当中，容易被窃取

防御：不落地加载：
解密后的dex不写入文件，通过自定义application接管生命周期
破解：dump内存中的dex

指令抽离：
将DEX函数代码抽离到外部文件，运行时动态恢复

指令转换：
使用自定义的解释器代替系统解释器，依赖JNI接口交互

虚拟机保护：
将代码编译为虚拟机指令，通过独立执行环境运行核心代码，兼容多语言，反调试

防御手段：代码混淆，资源加密，签名校验，反调试，防注入



SE Android
强制访问机制，符合策略才能访问，即使是root用户
SE Android通过强制访问控制（MAC）机制，对系统中的进程、文件、网络等资源进行严格的权限管理，确保即使进程被攻击或滥用权限，也能限制其访问范围，从而减少安全风险


ollvm

内存dump
- ​**控制流平坦化**：将逻辑转为状态机，增加分支复杂度     if变switch  
- **deFlux**：专用于恢复OLLVM控制流扁平化的工具
- angr

- ​**指令替换**：用等效但复杂的指令替换简单操作（如`ADD`→`SUB + NEG`）

- ​**虚假控制流**：插入无效分支干扰分析



安卓加固：
1.SOVMP加固，虚拟机保护
2.反frida/xposed  检测xposedbridge类，扫描frida端口

3.代码混淆使用`mov`指令替换`add`指令，或者使用`and`指令替换`or`指令，使程序执行结果不变，但反汇编出来的代码更加复杂。

4.H5加固，将js编译为自定义字节码


反调试：
调试器检测，模拟器检测
ptrace检测，ptrace占坑，进程检查
端口检测
时间差检测
双进程监控


安卓应用漏洞：
#### **应用克隆漏洞**

**原理**：攻击者利用Android WebView的跨域访问漏洞（如`setAllowFileAccessFromFileURLs`或`setAllowUniversalAccessFromFileURLs`配置不当），通过恶意链接或二维码诱导用户点击，从而窃取应用数据并克隆用户账户

**危害**：

- 攻击者可完全控制用户账户（如支付宝、银行APP），进行盗刷、信息窃取等

- 无需用户安装恶意应用，隐蔽性强

####  **Activity暴露攻击**

**原理**：未设置`android:exported="false"`的Activity可被其他应用调用，导致界面劫持或敏感操作绕过

**危害**：

- 仿冒登录界面钓鱼（如伪造银行Activity）

- 绕过权限检查，执行未授权操作（如发送短信



不落地加载壳  blackdex
root检测  shamiko隐藏root权限




利用抓包工具证书渗透

v1 MF文件列出所有文件的hash  .SF文件对MF文件的签名摘要 RSA文件是开发者的公钥证书和签名
rsa公钥解密sf签名，得到hash，计算mf的哈希是否相同，检测mf文件hash是否与实际相同

v2 全文件签名，分块hash，完整性验证

v3密钥轮换，新密钥必须要旧密钥签名，形成证书链
### (1) 常见攻击手法**

1. ​**修改 `AndroidManifest.xml`**：
    - 删除 `<application android:debuggable="false">` 或启用调试标志。
2. ​**Hook 签名校验函数**：
    - 使用 Frida/Xposed 拦截 `PackageManager.getPackageInfo()`。
3. ​**直接替换签名文件**：
    - 用自签名证书重新生成 `META-INF/` 文件（需对齐 ZIP 结构）。
4. ​**动态加载 Dex**：
    - 通过 `DexClassLoader` 加载未签名的代码。
#### 漏洞
下载腾达固件包，binwalk提取文件，
httpd文件ida静态分析，从url的参数提取字符串，进行strcpy，未进行长度验证
qemu模拟固件环境，设置虚拟网卡，复现漏洞


**LLVM pass**
将原函数的基本块转换为switch case结构，隐藏原始控制流
将add，xor替换为等价复杂表达式
虚假分支插入，不可达分支
字符串加密，运行时解密

代码插桩


LD_PRELOAD一个环境变量，允许用户在程序运行时优先加载自定义的动态库，从而劫持或者替换系统库函数，优先级最高






d3piano


模拟钢琴的app，按键传入整数，通过索引打乱传入整数的顺序，然后check
进行rsa加密检查是否正确
最后出来一个fakeflag
看别的lib

initarray可疑函数 初始化三个信号量  创建了四个线程 每个线程执行不同的函数

通过线程名称来检测是否处于调试或者hook状态，
根据hash获取到另一个库的对应的lib基址，得到函数地址，调用两个虚表函数，进行hook修改


alicepuzzle

多进程守护，ptrace双向检测
父进程通过 `fork()` 生成子进程，子进程复制父进程的内存和上下文。

父进程检测ptrace返回的状态码，如果检测到SIGTRAP调试信号，就进行SMC，程序自修改，进行混淆

不落地加载，

被调试的子进程，创建了一个匿名内存文件，读取rdata数据，动态加载一个elf文件，

子进程发送信号，父进程处理信号，进行内存篡改，传递输入，smc修改解密elf文件

获得真正的解密函数
Fillomino游戏 
规则相同数字的块连在一起称为一个区域，每个区域的块数必须等于每个块的数字



APP：
后台流量消耗，下载广告SDK
通讯录/短信窃取，位置跟踪
各种充值通道，频繁跳转支付


安全防护技术

加密技术

身份验证，多因素验证

访问控制 SELinux严格限制权限

代码层防护 静态分析  交互式分析

运行时防护  app加固+运行时沙箱

网络层防护 防火墙 WAF IDS/IPS



四大组件漏洞，不安全的数据存储
activity暴露，解密劫持，钓鱼攻击   恶意应用监听`android.intent.action.VIEW`
Service暴露，恶意应用直接绑定服务并调用支付接口  关闭导出
BroadcastReceiver暴露

通信层：中间人，伪造证书，http，硬编码加密密钥
权限滥用



加固手段：
网易易盾
梆梆加固 dex分片加载 内存完整性检测
爱加密
360加固

代码混淆：java progurad         native    ollvm 或者自己编写pass

加壳：压缩壳，加密壳，虚拟化虚拟机壳，动态解密，防止静态分析

反调试：isDebuggerPresent checkremotedubuggerPresent，
Linux：ptrace，Tracepid
时间差检测，
断点检测，int3断点，
检测调试寄存器
环境检测，进程
SEH


运行时保护，监控进程内存和代码完整性，防止篡改
内存hash校验
反钩子
环境检测
多进程守护

多态代码保护
代码重写，SMC



防范沙箱逃逸
沙箱防护