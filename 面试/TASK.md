##### **web**
SQL注入[教程](https://www.runoob.com/sql/sql-injection.html#:~:text=SQL%20%E6%B3%A8%E5%85%A5%EF%BC%88SQL%20Injection%EF%BC%89%E6%98%AF%E4%B8%80%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB%E6%89%8B%E6%AE%B5%EF%BC%8C%E6%94%BB%E5%87%BB%E8%80%85%E9%80%9A%E8%BF%87%E5%9C%A8%E8%BE%93%E5%85%A5%E5%AD%97%E6%AE%B5%E6%88%96%E8%AF%B7%E6%B1%82%E4%B8%AD%E6%B3%A8%E5%85%A5%E6%81%B6%E6%84%8F%E7%9A%84%20SQL%20%E8%AF%AD%E5%8F%A5%EF%BC%8C%E6%93%8D%E6%8E%A7%E6%95%B0%E6%8D%AE%E5%BA%93%E6%89%A7%E8%A1%8C%E6%84%8F%E5%9B%BE%E4%B9%8B%E5%A4%96%E7%9A%84%E6%93%8D%E4%BD%9C%E3%80%82,%E8%BE%93%E5%85%A5%E9%AA%8C%E8%AF%81%E4%B8%8D%E8%B6%B3%EF%BC%9A%E5%BD%93Web%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%B2%A1%E6%9C%89%E6%AD%A3%E7%A1%AE%E9%AA%8C%E8%AF%81%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5%E6%97%B6%EF%BC%8C%E6%94%BB%E5%87%BB%E8%80%85%E5%8F%AF%E4%BB%A5%E5%9C%A8%E8%BE%93%E5%85%A5%E5%AD%97%E6%AE%B5%E4%B8%AD%E6%8F%92%E5%85%A5SQL%E4%BB%A3%E7%A0%81%E3%80%82%20%E6%8B%BC%E6%8E%A5SQL%E8%AF%AD%E5%8F%A5%EF%BC%9A%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%90%8E%E7%AB%AF%E9%80%9A%E5%B8%B8%E5%B0%86%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5%E4%B8%8ESQL%E6%9F%A5%E8%AF%A2%E6%8B%BC%E6%8E%A5%E5%9C%A8%E4%B8%80%E8%B5%B7%EF%BC%8C%E5%BD%A2%E6%88%90%E5%AE%8C%E6%95%B4%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E3%80%82%20%E6%89%A7%E8%A1%8C%E6%81%B6%E6%84%8FSQL%EF%BC%9A%E5%A6%82%E6%9E%9C%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%B2%A1%E6%9C%89%E5%AF%B9%E8%BE%93%E5%85%A5%E8%BF%9B%E8%A1%8C%E9%80%82%E5%BD%93%E7%9A%84%E6%B8%85%E7%90%86%E6%88%96%E8%BD%AC%E4%B9%89%EF%BC%8C%E6%81%B6%E6%84%8FSQL%E4%BB%A3%E7%A0%81%E5%B0%86%E8%A2%AB%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%89%A7%E8%A1%8C%E3%80%82%20%E6%95%B0%E6%8D%AE%E6%B3%84%E9%9C%B2%E6%88%96%E7%A0%B4%E5%9D%8F%EF%BC%9A%E6%94%BB%E5%87%BB%E8%80%85%E5%8F%AF%E4%BB%A5%E5%88%A9%E7%94%A8SQL%E6%B3%A8%E5%85%A5%E6%9D%A5%E6%9F%A5%E8%AF%A2%E3%80%81%E4%BF%AE%E6%94%B9%E6%88%96%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%8C%E6%88%96%E8%80%85%E6%89%A7%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%B3%BB%E7%BB%9F%E5%91%BD%E4%BB%A4%E3%80%82%20%E5%BD%93%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E7%BD%91%E7%AB%99%E6%97%B6%EF%BC%8C%E9%80%9A%E5%B8%B8%E4%BC%9A%E8%BE%93%E5%85%A5%E7%94%A8%E6%88%B7%E5%90%8D%E5%92%8C%E5%AF%86%E7%A0%81%E3%80%82)

放置于Form表单或者请求参数中
绕过检测，获取敏感数据，触发数据库错误
盲注，布尔型，时间型

XSS跨站脚本攻击
反射：点击带有js脚本的链接
存储：存储于服务器，访问者触发


CSRF跨站请求伪造

DNS劫持

JSON劫持


##### ​pwn


**House of Botcake** 是一种针对 ​**glibc 2.29 及以上版本**的堆利用技术，主要用于绕过 ​**tcache** 中的 ​**double free 检测机制**，从而实现任意内存读写或代码执行

1. ​**绕过 tcache key 检测**
    
    - 在 glibc 2.29+ 中，tcache 引入了 `key` 字段（指向所属的 tcache 结构体），用于检测 double free。直接对同一 chunk 多次 free 会被拦截

    - ​**House of Botcake** 通过以下步骤绕过检测：
        1. ​**填满 tcache bin**：先释放 7 个同大小的 chunk 填满 tcache。
        2. ​**释放到 unsorted bin**：继续释放两个相邻的 chunk（如 chunk A 和 B），它们会合并进入 unsorted bin，此时不会设置 `key` 字段。
        3. ​**触发 double free**：从 tcache 中申请一个 chunk 腾出空间，再释放之前合并到 unsorted bin 的 chunk A，此时 chunk A 同时存在于 tcache 和 unsorted bin 中，形成 double free

2. ​**利用合并机制控制指针**
    
    - 通过堆块合并（unsorted bin）和重新分配，可以篡改 tcache 的 `next` 指针，最终实现 ​**任意地址分配**​（如修改 `__free_hook` 为 `system` 地址）





##### xposed
xposed
- **Hook机制**：通过劫持Android系统的 ​**Zygote进程**​（应用孵化器），在运行时拦截并修改Java方法的调用逻辑


- ​**模块化设计**：用户安装的Xposed模块以插件形式注入系统，按需修改特定功能（如界面、权限等），无需重新编译APK
	非侵入式修改，保留APK完整性


脚本编写：初始化，hook设置，数据处理

利用：
1. **ptrace 系统调用**
2. **访问** **`/proc`** **文件系统**：每个进程的各种信息（如内存映射、寄存器状态等）
3. **修改进程地址空间**


##### frida
过程：
frida的动态库注入
拦截函数调用
访问进程内存
修改目标函数的入口地址，使其跳转到 Frida 的处理代码。
修改目标进程的堆栈和寄存器来执行 Hook 逻辑。

1.java.perform
2.java.use(包名)

3.Interceptor.attach

**动态插桩**：在目标程序运行时注入代码，无需修改源码或重新编译
​**Hook 能力**：拦截函数调用、修改参数/返回值、监控内存访问等-

##### smali
smali
.class 类名
.field private a:Z 布尔类型私有变量a
.method 方法
.locals 2 表示方法里面有两个寄存器
.parameter 方法参数
.param p1, "haha" 方法里面有一个参数p1，它的值为"haha"
.prologue 方法开始
|boolean|Z|
|byte|B|
|short|S|
|char|C|
|int|I|
|long|J|
|float|F|
|double|D|
|void|V|

l Dex文件反编译后的文件，得到Smali代码，可以用于分析代码、分析逻辑，知道别人软件的这个功能是怎么实现的。

l Dex文件还可以反编译为JAR包，JAR包就是JAVA代码。

l 为什么用Smali代码不用JAVA代码分析，就是因为JAVA代码混淆比较严重，主要混淆是“函数名”，“类名”，“变量”，“包名”。
##### Android系统
#Android系统架构
1. Linux内核层
	1. 硬件驱动
	2. 进程管理
	3. 内存管理
	4. 安全机制
	5. 电源管理
2. 硬件抽象层HAL
	6. 硬件提供接口
3. 系统运行时库（lib） Android Runtime
4. 应用java框架层
5. 应用层




##### 沙盒与Fuzzing
基于模型的fuzzing 
向目标程序提供非预期随机的异常数据，触发潜在的漏洞

发现内存错误，释放后使用，空指针解引用
发现逻辑缺陷，认证绕过，条件竞争
验证健壮性，处理异常输入的能力

peach fuzzer
pit文件提供数据模型，状态模型
http版本号fuzzing

v2签名块
将apk文件中的其他部分按照1mb大小分块获取摘要

v3 新添一个attr块

##### app和apk
apk打包
1. 资源预编译
2. 代码编译与转换，生成.class字节码，再转化为.dex文件
3. apk打包与对齐
4. 签名与发布
反编译
5. apktool解包，获取smali代码，资源文件，manifest
6. dex2jar将dex转化为.jar，用jadx查看
7. 资源分析
SE Android
强制访问机制，符合策略才能访问，即使是root用户
SE Android通过强制访问控制（MAC）机制，对系统中的进程、文件、网络等资源进行严格的权限管理，确保即使进程被攻击或滥用权限，也能限制其访问范围，从而减少安全风险

破解：
1.smali代码篡改
2.资源替换
3.xposed/frida 动态注入
4.内存修改
5.签名绕过


##### 加固
防御：动态加载：
应用分为loader和payload两部分，运行loader解密payload动态加载
破解：payload需要释放到文件系统当中，容易被窃取

防御：不落地加载：
解密后的dex不写入文件，通过自定义application接管生命周期
破解：dump内存中的dex

指令抽离：
将DEX函数代码抽离到外部文件，运行时动态恢复

指令转换：
使用自定义的解释器代替系统解释器，依赖JNI接口交互

虚拟机保护：
将代码编译为虚拟机指令，通过独立执行环境运行核心代码，兼容多语言，反调试

防御手段：代码混淆，资源加密，签名校验，反调试，防注入






ollvm

内存dump
- ​**控制流平坦化**：将逻辑转为状态机，增加分支复杂度     if变switch  
- **deFlux**：专用于恢复OLLVM控制流扁平化的工具
- angr

- ​**指令替换**：用等效但复杂的指令替换简单操作（如`ADD`→`SUB + NEG`）

- ​**虚假控制流**：插入无效分支干扰分析



安卓加固：
1.SOVMP加固，虚拟机保护
2.反frida/xposed  检测xposedbridge类，扫描frida端口

3.代码混淆使用`mov`指令替换`add`指令，或者使用`and`指令替换`or`指令，使程序执行结果不变，但反汇编出来的代码更加复杂。

4.H5加固，将js编译为自定义字节码


反调试：
调试器检测，模拟器检测
ptrace检测，ptrace占坑，进程检查
端口检测
时间差检测
双进程监控




不落地加载壳  blackdex
root检测  shamiko隐藏root权限



##### 抓包和签名
利用抓包工具证书渗透

v1 MF文件列出所有文件的hash  .SF文件对MF文件的签名摘要 RSA文件是开发者的公钥证书和签名
rsa公钥解密sf签名，得到hash，计算mf的哈希是否相同，检测mf文件hash是否与实际相同

v2 全文件签名，分块hash，完整性验证

v3密钥轮换，新密钥必须要旧密钥签名，形成证书链
#####  攻击手法

1. ​**修改 `AndroidManifest.xml`**：
    - 删除 `<application android:debuggable="false">` 或启用调试标志。
2. ​**Hook 签名校验函数**：
    - 使用 Frida/Xposed 拦截 `PackageManager.getPackageInfo()`。
3. ​**直接替换签名文件**：
    - 用自签名证书重新生成 `META-INF/` 文件（需对齐 ZIP 结构）。
4. ​**动态加载 Dex**：
    - 通过 `DexClassLoader` 加载未签名的代码。
##### 漏洞挖掘
下载腾达固件包，binwalk提取文件，
httpd文件ida静态分析，从url的参数提取字符串，进行strcpy，未进行长度验证
qemu模拟固件环境，设置虚拟网卡，复现漏洞


##### **LLVM pass**
将原函数的基本块转换为switch case结构，隐藏原始控制流
将add，xor替换为等价复杂表达式
虚假分支插入，不可达分支
字符串加密，运行时解密
代码插桩



#LDpreload
LD_PRELOAD一个环境变量，允许用户在程序运行时优先加载自定义的动态库，从而劫持或者替换系统库函数，优先级最高





##### CTF
d3piano


模拟钢琴的app，按键传入整数，通过索引打乱传入整数的顺序，然后check
进行rsa加密检查是否正确
最后出来一个fakeflag
看别的lib

initarray可疑函数 初始化三个信号量  创建了四个线程 每个线程执行不同的函数

通过线程名称来检测是否处于调试或者hook状态，
根据hash获取到另一个库的对应的lib基址，得到函数地址，调用两个虚表函数，进行hook修改


alicepuzzle

多进程守护，ptrace双向检测
父进程通过 `fork()` 生成子进程，子进程复制父进程的内存和上下文。

父进程检测ptrace返回的状态码，如果检测到SIGTRAP调试信号，就进行SMC，程序自修改，进行混淆

不落地加载，

被调试的子进程，创建了一个匿名内存文件，读取rdata数据，动态加载一个elf文件，

子进程发送信号，父进程处理信号，进行内存篡改，传递输入，smc修改解密elf文件

获得真正的解密函数

Fillomino游戏 
规则相同数字的块连在一起称为一个区域，每个区域的块数必须等于每个块的数字



APP：
后台流量消耗，下载广告SDK
通讯录/短信窃取，位置跟踪
各种充值通道，频繁跳转支付


安全防护技术

加密技术

身份验证，多因素验证

访问控制 SELinux严格限制权限

代码层防护 静态分析  交互式分析

运行时防护  app加固+运行时沙箱

网络层防护 防火墙 WAF IDS/IPS


##### 安卓漏洞
四大组件漏洞，不安全的数据存储
activity暴露，解密劫持，钓鱼攻击   恶意应用监听`android.intent.action.VIEW`
Service暴露，恶意应用直接绑定服务并调用支付接口  关闭导出
BroadcastReceiver暴露
https://blog.csdn.net/tabactivity/article/details/125481157


通信层：中间人，伪造证书，http，硬编码加密密钥
权限滥用



##### 加固方案：
网易易盾
梆梆加固 dex分片加载 内存完整性检测
爱加密
360加固
腾讯乐固
腾讯御加固

代码混淆：java progurad         native    ollvm 或者自己编写pass

加壳：压缩壳，加密壳，虚拟化虚拟机壳，动态解密，防止静态分析

反调试：isDebuggerPresent checkremotedubuggerPresent，
Linux：ptrace，Tracepid
时间差检测，
断点检测，int3断点，
检测调试寄存器
环境检测，进程
SEH


运行时保护，监控进程内存和代码完整性，防止篡改
内存hash校验
反钩子
环境检测
多进程守护

多态代码保护
代码重写，SMC



防范沙箱逃逸
沙箱防护