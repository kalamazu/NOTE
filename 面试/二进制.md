[安卓](https://blog.csdn.net/freeking101/article/details/105329932)
[bagu](https://www.bagujing.com/problem-bank/48)
[bagu](https://blog.csdn.net/qq_32731075/article/details/124933885)
[frida](https://zhuanlan.zhihu.com/p/540785352)
[SEH]()
## C/C++
1. c/c++结构体大小如何计算
			1. 内存对齐原则：
				 成员对齐：每个成员相对于结构体起始地址的偏移量需为其类型大小和对齐系数（如 `#pragma pack(n)`）的较小值的整数倍。
				 整体对齐：结构体总大小需为最大成员对齐值的整数倍。
				 **示例**：`struct { char a; int b; }` 在默认对齐（4字节）下大小为 8 字节（1+3填充+4）。
			 2. 编译器影响 `#pragma pack(n)` 可强制对齐系数为 `n`，但可能牺牲性能
	
2. c++结构体和c结构体的区别
			1. 功能扩展，c++结构体支持成员函数，继承，多态，访问控制，与类的唯一区别是默认访问权限
			2. c的限制，c结构体仅包含数据成员，无封装，继承等特性
	
3. new/delete与malloc/free的区别
			1. 构造和析构，new调用构造函数，delete调用析构函数；malloc/free仅分配释放内存
			2. 类型安全，new返回类型指针，malloc返回void* 需要强转
			3. 异常处理，new失败抛异常，malloc返回NULL
			4. 重载与扩展，new/delete可重载，malloc/free不可以
	
4. 找main函数
			1. 控制台程序，main
			2. windowsgui程序，winmain
			3. linux程序，main
			编译器链接启动代码，调用main，通过编译参数和运行时库确定
	
5. 构造函数与析构函数调用时机
			1. 构造，对象创建
			2. 析构，对象销毁
	
6. c/c++编程中的安全问题
			1. 浅拷贝和双释放：默认拷贝构造函数导致指针成员重复释放，需要深拷贝和智能指针
			2. 内存问题，缓冲区溢出，内存泄漏，野指针
			3. 使用std：：string，容器类，RAII，智能指针
	
7. 重载和重写
			1. 重载（静态多态：同一作用域同名函数，参数列表不同，编译时通过名称修饰决议
			2. 重写（动态多态：虚函数仔派生类中覆盖，运行时通过虚表决议
	
8. 虚函数实现机制
			1. 虚表：每个虚函数的类有一个虚表，存储函数指针
			2. 虚表指针：对象首部含有vptr，指向虚表
			3. 动态绑定：运行时通过vptr查找虚表，调用实际函数
	
9. 虚继承/多重继承的内存结构
			1. 解决菱形继承问题，虚基类子对象在派生类中唯一，通过虚基类表（vbptr）或偏移量访问
			2. 多重继承：基类按声明顺序排列，每个基类可能含有独立vptr
			3. **编译器差异**：VC++与GCC虚表结构不同，如VC++虚表含虚基类偏移。
10. switch的实现和优化
			4. 跳转表：连续密集case生成跳转表
			5. 二分/线性搜索：分散case可能编译为二分或者线性比较
			6. 性能对比：跳转表效率最高，但受case分布影响
	
11. try-catch实现与优化
			1. 栈展开：异常抛出时回溯调用栈，匹配catch块
			2. 异常表：编译器生成元数据记录try块范围以及catch类型
			3. windows SEH：结构化异常处理，每个函数注册异常回调
			4. 性能开销：异常处理增加元数据管理，频繁使用影响性能
	
12. 三种循环效率对比
			1. 底层等价性：for，while，do-while编译为相似指令
			2. 微优化，dowhile减少一次条件判断（末尾优化），但编译器优化后差异消失
	
13. 32位调用规定：
			1. cdecl参数右到左压栈，调用者清理
			2. stdcall被调用者清理
			3. fastcall部分参数通过寄存器
	
14. 64位调用约定
			4. **Windows (x64)**：前4整型（RCX、RDX、R8、R9），前4浮点（XMM0-3），栈由调用者清理。
			5. **System V (Linux)**：前6整型（RDI、RSI、RDX、RCX、R8、R9），前8浮点（XMM0-7）。
	

## 二进制逆向

1. 32位程序如何在64位机器上运行
		1. 兼容模式：64位系统提供32位程序的运行环境
		2. 文件系统重定向：32位程序访问`C:\Windows\System32`会被重定向到`C:\Windows\SysWOW64`
		3. **双注册表视图**：32位程序使用`Wow6432Node`分支注册表
		4. **指令翻译**：CPU在兼容模式下执行32位指令（x86模式）
2. PE文件格式
	1. DOS头：IMAGE_DOS_HEADER
	2. NT头：IMAGE_NT_HEADER(含可选头，文件头)
	3. 节表：`IMAGE_SECTION_HEADER`定义各节（.text, .data, .rdata等）
	4. 导入表IAT：记录依赖的DLL以及函数地址
	5. 重定位表：记录需要调整的地址偏移（ASLR
		关键字段：ImageBase，默认加载基址；EntryPoint，程序入口点OEP
3. PE文件加载和执行过程
	1. 内存映射：按节对齐（SectionAlignment，将PE文件映射到内存
	2. IAT初始化：解析导入表，加载依赖DLL并填充函数地址
	3. 重定位处理：若加载地址与ImageBase冲突，修正重定位表的地址
	4. 执行权限设置：设置代码段为可执行，数据段可读写
	5. 跳转OEP：从EntryPoint开始执行
4. 反调试手段
	1. 检测调试器：IsDebuggerPresent，CheckRomteDebuggerPresent
	2. 断点扫描：扫描代码段是否含有0xCC（INT3指令）
	3. 时间差检测：通过rdtsc指令检测执行时间异常
	4. SEH反调试：注册异常处理函数干扰调试器
	5. 环境检查：检测进程名，窗口类名，驱动
5. GDB：
	1. break * 0x地址：下断点
	2. x/10i $eip：反汇编当前指令
	3. info registers：查看寄存器
		ollydbg
		F2下断点，ctrl G跳转，ctrl A分析代码
6. 调试器断点实现：
			> 主要通过系统提供的调试接口附加进程：
			> Linux ptrace（），Windows Debug API，macOS，task_for_pid()
	1. 软件断点：替换指令为INT3（0xCC
	2. 硬件断点：使用调试寄存器（DR0-DR3      DR7决定哪些断点生效，支持执行，读，写断点
	3. 内存断点：修改内存页属性（如设为不可访问接触异常
			
7. 脱壳与修复导入表
	1. 找OEP：通过内存断点，栈平衡法，单步跟踪
	2. Dump内存：将解密后的代码段和数据段导出
	3. 修复IAT：使用ImportREC等工具重建导入表
	 修复的必要：壳可能加密或者破坏IAT
8. 花指令和混淆对抗
	1. 花指令插入无效指令，影响反汇编
	2. 反混淆方法：动态调试跳过，IDA脚本批量处理NOP无效代码
9. IDA脚本应用
	1. 批量重命名变量，函数
	2. 修复混淆代码
	3. 搜索提取特征码
10. 无字符串如何定位核心逻辑
	1. 动态跟踪，通过API调用，回溯关键代码
	2. 交叉引用，在IDA中查找加密函数或者特定常量引用
	3. 行为监控，使用Process Monitor捕获文件/注册表操作
11. 内存泄漏排查
	1. 工具：windows，CRT调试库，windbg，linux，Valgrind（memcheck工具
	2. 代码审查：检查new/delete，malloc/free是否匹配
12. 免杀技术
	1. 静态免杀，特征码修改，静态分析
		1. 代码混淆：字符串加密，变量函数重命名，垃圾代码填充，特征码隐藏
		2. shellcode加密：xor，AES，RC4加密，执行时解密
		3. 代码包装：UPX加壳压缩
		4. 文件格式变形：修改PE头，改动ELF/Mach-O文件结构
	2. 动态免杀，行为检测，动态分析
		1. API Hook绕过
		2. 反沙箱：检测虚拟机环境（cpu温度，进程列表
		3. 行为监控工具
		4. 反调试分析
13. Hook技术
	1. Inline Hook：修改函数入口指令跳转到自定义代码
	2. IAT Hook：替换导入表中的函数地址
	3. SSDT Hook内核层：修改系统服务调度表
	4. 异常处理：若Hook位置不足5字节，使用跳板保存原始指令
	5. 跳板技术：
14. 进程隐藏
	1. EPROCESS断链：修改内核ActiveProcessLinks链表移除自身
	2. 无影响：隐藏后进程可运行，但任务管理器无法显示
	3. 检测绕过：Rootkit通过驱动实现深度隐藏
15. 寄存器和内存管理：
	1. EFLAGS：
		1. ZF零标志（sub，cmp
		2. OF溢出标志
		3. SF信号标志（反映结果，运算为负，则1
		4. CF进位为1
		5. PF运算结果最低有效字节1的个数的奇偶性，偶数为1
		6. TF设置为1，cpu进入单步调试
		7. IF控制是否运行外部中断，1为允许
		8. DF控制字符串操作方向，1从高到低
		9. 虚拟标志位，CPU内部使用
			1. IOPL指示当前CPU操作是否允许I/O访问
			2. NT管理任务切换和嵌套任务的处理
			3. VM管理CPU是否在虚拟模式运行
	2. 控制寄存器作用：
		1. CR0：控制CPU工作模式和特性，保护模式和虚拟内存管理, PE，MP，EM，TS........
		2. CR2：存储发生页错误时的虚拟地址
		3. CR3：内存管理，控制分页机制
		4. CR4：控制现代x86处理器特性的寄存器
		5. CR8：CR8寄存器用于管理**中断优先级**，它与中断处理和系统级的中断管理密切相关
	3. 共享内存：多进程之间通信的一种机制，允许多个进程访问同一块物理内存区域
		1. 使用操作系统提供的共享内存API
		2. 内存映射：将一个文件或设备的内容映射到进程的地址空间
		3. 使用内存共享库
		4. 同步机制防竞争：信号量，互斥锁
16. windows下注入
	1. DLL注入：强制目标进程加载指定DLL，触发DLL入口点执行代码
	2. 代码注入：
	3. APC注入（异步过程调用：向目标线程的APC队列插入回调函数，当线程进入可警报状态时执行APC队列的回调函数
	4. 可警报状态：调用特定函数时候进入
17. 虚拟机与虚拟化
	1. QEMU，VMware，Bochs
	2. 全虚拟化：虚拟机完全模拟硬件，虚拟机操作系统认为自己在与硬件直接交互，实际上，它是通过虚拟机监控程序（Hypervisor）与物理硬件进行交互
	3. 半虚拟化：在半虚拟化中，虚拟机与虚拟机监控程序合作，虚拟机内核会被修改以与虚拟机监控程序协作。半虚拟化在性能上相对于全虚拟化有更好的优化，因为它不需要模拟硬件
	4. 操作系统级虚拟化：操作系统级虚拟化通过在单个操作系统内核上运行多个用户空间的实例，这些实例相互隔离，但共享操作系统内核。（Docker
	5. 硬件辅助虚拟化：使用现代 CPU 提供的硬件扩展（如 Intel VT-x、AMD-V）来加速虚拟化，减少虚拟化的开销。
18. 虚拟机查杀
	1. 检查硬件特征：检查CPU标识
	2. 检查定时器与系统时钟
	3. 检查设备驱动程序：虚拟机环境中通常会插入一些特定的虚拟硬件设备，如虚拟显卡、虚拟硬盘，检查这些设备
	4. 检查系统行为
	5. 检查文件系统
	6. 检查网络行为
19. 防止内存检查
	1. 内存加密
	2. 动态修改内存布局
		1. 内存布局混淆
		2. 堆栈保护
	3. 反扫描技术
		1. 反调试
		2. 反内存扫描mprotect
	4. 内存保护机制
		1. 硬件辅助保护，虚拟化技术Intel TXT
		2. 内存访问控制：操作系统或者虚拟化技术
	5. 代码混淆加密
	6. 内存自检和清理
20. DEP（数据执行阻止）将内存中的代码区和数据区明确区分开来，阻止数据页执行代码

## 漏洞
1. Canary原理和绕过
	1.  fs寄存器，插入随机数canary在栈帧中（ebp下面
	2. 返回时检查canary是否与预期值匹配
	3. 绕过：
		1. 读取栈上的canary（覆盖截断字符，格式化字符串打印
		2. 劫持stack_chk_fail函数（处理canary异常的
		3. 爆破
		4. ssp
2. 堆溢出
	1. fastbin：存放一块已释放的堆内存的垃圾桶，里面是链表结构
	2. fastbin是这样用的，我们刚才释放了B，随后我们再申请相同大小的，我们就会得到B
	3. 修改指针：
		1. 释放A、B内存堆，B的next指针就是A，如果再释放一次A，A的next指向B，达到修改指针的目的
	4.向堆块写入超过userdata的数据，覆盖相邻chunk元数据，控制函数指针

## **漏洞挖掘**
1. Fuzzing模糊测试
	是一种自动化软件测试技术，通过向目标程序输入非预期的随机数据，监测程序是否崩溃，内存泄露等异常行为；
	1. ALF，VUzzer等工具

