[导图](导图1版(1).html)
协议逆向

js逆向
#### 安卓系统启动
充电
引导ROM
BootLoader
启动linux kernel
启动init程序
zygote进程
systemserver
应用启动

#### apk打包安装app启动
##### 启动流程

- 先从Launcher的startActivity方法通过binder通信，向system_server进程调用ActivityManagerSercvice的startActivity方法

- 向zygote进程通过socket发送创建进程的请求

- zygote进程fork出新的子进程，即app进程

- app进程通过binder向system_server进程发起attachApplication请求

- system_server进程收到请求后，进行一系列工作，通过binder向app进程发送schedulelaunchactivity请求

- app进程收到请求之后，通过handle向主线程发送LAUNCH_ACTIVITY消息

- 主线程收到message，通过发射机制创建目标activity，回调activity的onCreate等方法
##### APK
dex
lib
asset静态资源
res/ 编译资源
androidnmainifest配置清单文件
resouces.arsc 资源映射文件
#### APP漏洞
##### AndroidManifest配置漏洞：
四大组件暴露漏洞activity Broadcastreciever contentprovider service
程序可调式
程序数据任意备份

##### WebView组件以及与服务器通信风险漏洞：
忽略ssl证书错误
启用访问文件数据 
开放socket端口

##### 数据安全：
SD卡数据被第三方访问
全局file可读

私有文件泄露风险
数据明文，证书明文
AES弱加密，使用ecb模式

弱随机数
密钥硬编码

##### 内存堆栈保护
未开启PIE，未开启canary保护
可读可写可执行权限


#### app逆向经验
##### 美团
加固混淆
1.libmtgurd 防护库

2.关键字符串（类名，方法名，路径，密钥）经过一个native函数动态解密
3.代码混淆与控制流平坦化，native层混淆，无法直接F5，或者清楚分析出代码逻辑，代码块动态跳转计算
4.PIC数据，动态生成的，多层加密的json数据包

运行环境检测
1.root检测：检查特定路径是否存在su，magisk等文件
2.模拟器检测：检查驱动，硬件信息
3.Hook框架与调试检测：进程内存扫描，检测是否有可疑的Hook动态库fridagadget；检测xposed，检测XposedBridge类是否被加载；调试器检测，占用Ptrace等方式阻止调试器附加
4.沙箱检测 代理检测。。。。。

         信息可以大致分为：软件ID、软件静态特征、硬件静态特征和硬件动态特征。采集完信息后如何基于这些信息计算出一个稳定的设备指纹ID，还是有比较大挑战，再加上目前国家对公民隐私保护严格，用户敏感信息不能采集，很多唯一性比较好的数据就失效，要做一稳定性高的ID就难上加难了
设备指纹与唯一性标识
1.多维信息采集：硬件信息，软件信息，设备环境，陀螺仪，mac，硬件id
不能采集的：sim卡，应用列表，精确地理位置，生物识别数据
2.每个网络请求都携带一个mtgsig签名参数包含：
- 数据
- 设备指纹信息
- 时间戳
- 加密密钥（从资源文件动态解密获得）
- 多次AES，MD5，CRC校验，密钥由多个来源组合，难以预测。。
- 每次请求独立签名，抓包重放难度高
服务端用同样的加密算法，同样的参数，校验客户端的信息是否真实

黑产工具检测：
PIC资源文件，特征库加密存储
动态扫描检测



##### 360加固

壳DEX-》壳ELF-》主ELF-》主DEX
壳DEX：字符串加密，动态解密，progurd混淆
壳ELF：清除导入导出表，动态加载核心逻辑，自实现Linker，启动主ELF
主ELF：段加密分离，将关键段加密存储到其他位置，运行时解密，实现自加载，最后VMP解密主DEX，获得脱壳后DEX
主DEX：应用逻辑

反调试和环境检测：
1.进程检测，maps，TracerPid，进程名
2.反调试，双进程守护 pthread_create

采用加密RC4，Base64，Zlib压缩

frida-hexdump
FART

##### 鸿蒙逆向
.hap
查看manifest，ablility和包含的二进制
ark方舟编译器，方舟运行时
HDC
abc文件

手势锁
nativehook检测
xxtea解密，key 硬编码
原始图片-SM4魔改-base64-enc文件
上传图片，显示flag

#### 重打包
hash对比
签名对比
DEX，资源文件进行hash或者相似度对比
逆向分析，看看有没有插入可疑sdk或者库
网络流量分析，有没有向可疑的服务器发送数据
API调用监控，使用xposed，frida

#### /proc
self：用于指向自己的进程
maps：展示当前进程的内存空间分布，代码，数据，堆，栈分布在哪里
status
cmdline
fd

cpuinfo
meminfo



#### 加固总体方向
反调试：

代码混淆和抗逆性：

完整性反篡改和运行时保护：

环境和设备检测：

应用架构和流程安全（安全开发）（数据安全）：

安全通信防抓包：

一代：proguard，字符串加密，静态dex整体加密解密
二代：DEX动态加载，DEX抽取到外部，so加密，不落地加载
三代：DEX代码动态解密，so代码混淆
四代：VMP

#### H5加固
H5应用，基于HTML5，CSS3，JS等现代Web技术构建的交互式网页应用

JShaman
网易易盾
javascript-obfuscator

代码混淆：控制流平坦化
反调试：
防篡改
VMP
域名锁定：
代码保护：
webassembly：wasm

#### 脱壳
##### frida-hexdump:本质是ptrace调试
先要过反调试，然后内存扫描dump

##### blackdex：基于app_process
主动启动java程序，调用blackdex.so，获取目标进程内存访问权，遍历内存映射，找到可读可执行的dex代码

##### FART
[原理](https://xialuohun.top/posts/android/android%E5%A3%B3%E4%B8%96%E7%95%8C/fart%E6%B5%81%E7%A8%8B%E5%92%8C%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/)
主动调用的方式

在Activity启动时插入钩子，启动脱壳线程
修改方法调用入口，判断是否为FART调用，若是，则dump流程而不是执行

**绕过Libc Hook**​：在Native层执行Dump操作时，FART**直接使用底层的系统调用**

##### DexExtractor

修改Android系统底层源码，再Dex文件被加载的关键时刻自动将其从内存抓取出来

修改路径：修改ART/Dalvik虚拟机的 `DexFile.cpp` 中的 ​**`dexFileParse`函数**，这是系统解析Dex文件的必经之路

对抗检测：将Dump下来的Dex数据先进行**Base64编码**再写入文件，以绕过加固方案对直接内存Dump的检测

部署方式：修改system.img

#### 签名校验
v1 MF文件列出所有文件的hash  .SF文件对MF文件的签名摘要 RSA文件是开发者的公钥证书和签名
rsa公钥解密sf签名，得到hash，计算mf的哈希是否相同，检测mf文件hash是否与实际相同

v2 全文件签名，分块hash，完整性验证

v3密钥轮换，新密钥必须要旧密钥签名，形成证书链

#### 反调试手段

第一类：proc进程信息文件系统目录下系统属性检测
status：TracePid查看这个字段，是否被ptrace调试
maps：查看端口，字符串，等等内存映射信息有无调试器gdb，frida 或者又执行权限的未知内存空间，检测可疑进程

第二类：ptrace反调试
ptrace允许一个进程（称为 ​**tracer**，跟踪者）观察和控制另一个进程（称为 ​**tracee**，被跟踪者）的执行
1.抢占调试槽
2.双进程守护：相互轮询，ptrace检测/proc/pid/status的TracerPid；检测进程的LD_PRELOAD,frida,gdbserver,修改的GOT
3.底层 svc指令执行ptrace

第三类：常规反调试
利用系统api检测  isDebuggerConnected waitForDebugger，检测环境变量，检测manifest debug属性

调试器特征针对的字符串搜索：frida-agent fridagadget xposedbridge

第四类：异常处理反调试
设置异常处理器：故意设置SIGTRAP信号暂停，如果被捕获，应用就发现了调试，暂停程序：只需要让调试器pass掉这种信号即可，或者hook signal函数

计时器检测：获取高精度时间，计算执行代码时间

第五类：环境检测
模拟器，虚拟机，root，xposed，frida

第六类：VMP反调试




对抗：
1.时间差
2.修改二进制
3.动态hook，或者ldpreload环境伪造



#### 代码混淆
ollvm功能
-fla控制流扁平化
-bcf插入伪控制流
-sub指令替换
-split拆分基本块


第一level：字符串加密，名称混淆

VMP
ollvm和其他pass
加保护壳，动态解密代码，延迟解密
运行时smc自修改代码


花指令：
	call附近，再返回
	jmp附近
	
	jz
	jnz：互补条件跳转，绕过垃圾指令
	
	永真跳转
	
	不可执行代码（被跳过）
	
	破坏堆栈平衡
	成对出现压栈入栈，inc dec操作

Dex2C技术：
代码膨胀
内存，指针管理
java与c的兼容性，java包装程度高
大量jni接口使用
#### vmp
Code Virtualizer
VMProtect
Themida

基本组成：
字节码
虚拟机状态（寄存器，栈，指令指针，内存区，flags）
调度器（读字节码，解码opcode，跳转到handler）
handler：每个opcode的对应实现，完成虚拟指令语义

调度器技术：
switchcase
间接跳表jump table
异常驱动
利用异常机制来跳转，触发分支
计算取值，从opcode的复杂计算得到handler地址


辅助组成：字节码生成器，把目标函数转化为字节码并嵌入二进制
JIT，对高频字节码即时编译回原代码以提高性能

VMP解释器包括dispathcher和handler：

设计模式：基于栈，基于寄存器，基于堆
1.设计指令集合
2.字节码格式
3.基于函数表的跳转，直接跳转；如何处理跳转
4.反调试手段：完整性检测，动态解密，多层嵌套vm
5.

#### IDA Python

F5原理：
首先判定函数范围
1.中间表示
2.数据流和符号追踪，还原变量生命周期
3.类型推断
4.控制流结构化
5.恢复栈变量和结构体

破坏F5，破坏堆栈平衡，滥用无返回函数属性（其实就是插入无用基本块），插入花指令

如何编写IDA Python

引入：

import idautils
工具层：提供迭代器和工具函数，用于遍历和枚举IDA数据库里的对象

import idaapi
底层API：提供底层接口和核心数据结构，功能最强大

import idc
命令层：提供高级易用的封装函数
（段，函数）名称，地址，内存读写，设置注释


基础用法：
1.遍历段，idautils.Segments()获取可迭代对象，可以获得对象的段名，起始结束地址，获取下一个段
2.遍历方法：for func in idautils.Functions():idc.get_func_name(func)，可以获得方法的起始结束地址，函数名称
3.遍历函数内指令for Instruct in idautils.FuncItems(Func_ea)

idc:获取信息，修改字节，注释，交互，反汇编
idc.generate_disasm_line()
idc.print_insn_mnem(ea) //返回指令助记符
idc.print_operand(ea,n)//打印第n个操作数
idc.next_head()
idc.get_screen_ea()
idc.get_inf_attr(idc.INF_MIN_EA)
idc.get_func_name(ea)
idc.get_func_attr(ea,idc.FUNCTATTR_START)
idc.set_name(ea,name)
idc.create_strlit(ea,end_ea)
idc.make_data(ea,flags,size,tid)
byte_val=ida.get_wide_byte(ea)
word_val=ida.get_wide_word(ea)
idc.patch_bytes(ea,val)//地址，目标修改
idc.set_cmt(ea,"Comment",0)
idc.ask_yn(0,"A dialog To warn")

idautils:遍历，交叉引用
idautils.Segments()
idautils.Functions()
idautils.FuncItems(ea)
idautils.XrefsTo(ea)//返回一个迭代器
idautils.XrefsFrom(ea)
idautils.DataRefsTo(ea)
idautils.Heads(start,end)//遍历区间指令头
idautils.Strings()//遍历字符串




idaapi:
idaapi.FlowChart(func)//返回基本块的迭代器
idaapi.msg /warning /info
注册一个菜单动作或快捷键
数据库操作，访问函数表，名称表
```python
# -*- coding: utf-8 -*-
import idc
import idautils
import idaapi

def print_segment_info():
    """打印所有段的信息"""
    print("=" * 80)
    print("段信息 (Segments Information)")
    print("=" * 80)
    
    for seg in idautils.Segments():
        seg_name = idc.get_segm_name(seg)
        seg_start = idc.get_segm_start(seg)
        seg_end = idc.get_segm_end(seg)
        seg_size = seg_end - seg_start
        
        print("段名: %-12s 起始: 0x%08X 结束: 0x%08X 大小: %d bytes" % 
              (seg_name, seg_start, seg_end, seg_size))

def print_function_info():
    """打印函数信息，包括标志位"""
    print("\n" + "=" * 80)
    print("函数信息 (Functions Information)")
    print("=" * 80)
    
    # 函数标志位映射
    flag_names = {
        idc.FUNC_NORET: "FUNC_NORET",
        idc.FUNC_FAR: "FUNC_FAR", 
        idc.FUNC_LIB: "FUNC_LIB",
        idc.FUNC_STATIC: "FUNC_STATIC",
        idc.FUNC_FRAME: "FUNC_FRAME",
        idc.FUNC_USERFAR: "FUNC_USERFAR",
        idc.FUNC_HIDDEN: "FUNC_HIDDEN",
        idc.FUNC_THUNK: "FUNC_THUNK"
    }
    
    func_count = 0
    for func_ea in idautils.Functions():
        func_name = idc.get_func_name(func_ea)
        flags = idc.get_func_attr(func_ea, idc.FUNCATTR_FLAGS)
        
        # 获取函数边界
        start_ea = idc.get_func_attr(func_ea, idc.FUNCATTR_START)
        end_ea = idc.get_func_attr(func_ea, idc.FUNCATTR_END)
        
        # 解析标志位
        active_flags = []
        for flag, name in flag_names.items():
            if flags & flag:
                active_flags.append(name)
        
        flag_str = ", ".join(active_flags) if active_flags else "None"
        
        print("函数: 0x%08X - %-30s 大小: %4d bytes" % 
              (start_ea, func_name, end_ea - start_ea))
        print("      标志位: %s" % flag_str)
        
        func_count += 1
    
    print("\n总计函数数量: %d" % func_count)

def analyze_current_function():
    """分析当前光标所在的函数"""
    print("\n" + "=" * 80)
    print("当前函数分析 (Current Function Analysis)")
    print("=" * 80)
    
    current_ea = idc.get_screen_ea()
    if current_ea == idc.BADADDR:
        print("错误: 无效地址")
        return
    
    func = idaapi.get_func(current_ea)
    if not func:
        print("错误: 当前地址不在函数内")
        return
    
    func_name = idc.get_func_name(current_ea)
    start_ea = func.start_ea
    end_ea = func.end_ea
    
    print("函数名: %s" % func_name)
    print("地址范围: 0x%08X - 0x%08X" % (start_ea, end_ea))
    print("函数大小: %d bytes" % (end_ea - start_ea))
    
    # 遍历函数指令
    print("\n指令列表:")
    print("-" * 60)
    
    current = start_ea
    instruction_count = 0
    
    while current < end_ea:
        if idc.is_code(idc.get_full_flags(current)):
            mnemonic = idc.print_insn_mnem(current)
            disasm = idc.generate_disasm_line(current, 0)
            
            # 获取操作数信息
            op_count = idc.get_operand_type(current, 0) != idc.o_void
            op1 = idc.print_operand(current, 0) if op_count else ""
            op2 = idc.print_operand(current, 1) if idc.get_operand_type(current, 1) != idc.o_void else ""
            
            print("0x%08X: %-8s %-15s %-15s | %s" % 
                  (current, mnemonic, op1, op2, disasm))
            
            instruction_count += 1
        
        current = idc.next_head(current, end_ea)
    
    print("指令数量: %d" % instruction_count)

def find_string_references():
    """查找字符串引用"""
    print("\n" + "=" * 80)
    print("字符串引用 (String References)")
    print("=" * 80)
    
    string_count = 0
    for segea in idautils.Segments():
        segname = idc.get_segm_name(segea)
        
        # 主要在代码段和数据段查找
        if segname in ['.text', '.data', '.rdata']:
            ea = idc.get_segm_start(segea)
            end = idc.get_segm_end(segea)
            
            while ea < end:
                if idc.is_strlit(idc.get_full_flags(ea)):
                    string_value = idc.get_strlit_contents(ea)
                    if string_value and len(string_value) > 3:  # 过滤短字符串
                        # 查找交叉引用
                        refs = list(idautils.DataRefsFrom(ea))
                        if refs:
                            print("字符串: '%s' at 0x%08X" % (string_value, ea))
                            for ref in refs[:3]:  # 显示前3个引用
                                print("  -> 被引用于: 0x%08X" % ref)
                            string_count += 1
                
                ea = idc.next_addr(ea)
    
    print("发现的字符串数量: %d" % string_count)

def analyze_imports_exports():
    """分析导入导出函数"""
    print("\n" + "=" * 80)
    print("导入表分析 (Imports Analysis)")
    print("=" * 80)
    
    import_count = 0
    for i in range(idaapi.get_import_module_qty()):
        name = idaapi.get_import_module_name(i)
        if not name:
            continue
            
        print("\n模块: %s" % name)
        print("-" * 40)
        
        def imp_cb(ea, name, ordinal):
            if name:
                print("  0x%08X: %s" % (ea, name))
            else:
                print("  0x%08X: ordinal#%d" % (ea, ordinal))
            return True
        
        idaapi.enum_import_names(i, imp_cb)
        import_count += 1
    
    print("\n导入模块数量: %d" % import_count)

def basic_analysis_report():
    """生成基础分析报告"""
    print("IDAPython 综合分析脚本")
    print("创建时间: %s" % idc.get_idb_path())
    print("IDA版本: %s" % idaapi.get_kernel_version())
    print("\n" + "=" * 80)
    
    # 执行各个分析功能
    print_segment_info()
    print_function_info()
    analyze_current_function()
    find_string_references()
    analyze_imports_exports()
    
    print("\n" + "=" * 80)
    print("分析完成!")
    print("=" * 80)

def main():
    """主函数"""
    try:
        # 保存当前光标位置
        original_ea = idc.get_screen_ea()
        
        # 执行分析
        basic_analysis_report()
        
        # 恢复光标位置
        idc.jumpto(original_ea)
        
        print("\n脚本执行完毕! 所有操作已完成。")
        
    except Exception as e:
        print("错误: %s" % str(e))
# 执行脚本
if __name__ == "__main__":
    main()
```
#### ARM汇编
数据传送 mov ldr/str
算术运算 add/sub
逻辑运算 xor/and
比较跳转 cmp B  BL BX BNE BEQ  标志：CPSR标志
BX跳到寄存器里的地址
BL跳到子程序
BLX跳到寄存器里的子程序
B跳到一个Lable

寻址方式：
立即寻址
寄存器寻址
寄存器间接寻址
偏移寻址机制
多寄存器寻址

寄存器：
x0返回值
x0-x7传参
x8返回值
x29是栈底地址
x30返回地址
x31栈顶地址
x32当前指令地址

状态寄存器CPSR   N  Z  C  V 
跳转和条件执行  B BL BX BEQ BNE  MOVEQ
存放和访问 LDR STR  

#### frida，xposed，magisk原理，使用，检测
bl-》kernel+ramdisk挂载根文件系统-》执行ramdisk的init
magisk修改ramdisk，最早插入自己的逻辑：
1.systemless挂载
2.修改SELinux
3.启动守护进程

magsik：systemless设计：创建一个Magisk分区，覆盖在原有的系统分区之上，所有修改都发生在这个虚拟层，而没有动system分区
MagiskSu替代su
把/system分区只读
Zygisk组件注入Zygote，影响之后孵化的每个进程
SELinux：MAC强制访问控制：getenforce查看策略：Enforcing Permissive  Disabled目的是保护系统不被意外破坏

frida：
hook java层：运行时方法替换，通过对应用程序的Java虚拟机（ART）
1.注入agent，ptrace实现，或者gadget实现
2.hook java虚拟机，拦截java代码执行，hook方法的implementation属性

hook native层：inline hook和got hook结合
got hook：Interceptorreplace的时候


xposed原理：
zygote接管，启动xposedbridge.jar，java反射机制
在ART插入XposedBridge





#### 抓包 ssl_pinning 双向TLS
HTTPS：
1.当你访问一个HTTPS网站时，浏览器（客户端）和服务器会开始一个称为TLS握手的过程 。
2.服务器会将其数字证书（由可信的证书颁发机构CA签发，内含服务器公钥）发送给浏览器 。
3.浏览器会严格验证这张证书的合法性，包括检查是否由受信任的CA签发、证书是否过期、以及证书绑定的域名是否与当前访问的域名一致等 。
4.验证通过后，浏览器会生成一个随机的会话密钥，并用证书中的服务器公钥加密后发送给服务器 
5.只有拥有对应私钥的服务器才能解密出这个会话密钥，也就是别的服务器获得不了对话信息

CA原理：
1.服务器发送CA给你
2.客户端的操作系统验证CA是否来自可信的渠道
抓包：
1.客户端想要访问外部服务器，但路径被代理挡住
2.客户端向代理建立连接，代理向服务端建立连接
3.客户端验证代理的CA，代理验证服务端的CA
4.系统安装了代理的CA，所以被信任
5.实现抓包

Android7以上只信任系统CA

ssl_pinning：在客户端把服务器证书或公钥写死缓存，客户端在建立TLS时同时检查证书是否匹配，从而阻止MITM
：Certificate Pinning：硬编码证书到app
：Public Key Pinning：只通过硬编码公钥来验证

1.使用OkHttp，通过OpenSSl获得正确公钥指纹
2.硬编码证书信息

JustTrustMe：将APK中所有用于校验SSL证书的API都进行Hook，从而绕过证书检查
OkHttp第三方网络库
javax.net.ssl.X509TrustManager 类 Android标准库
WebView组件


双向TLS校验：

#### so文件保护校验和加载
##### so加载
1.systemloadlibrary发起，在标准路径找lib；systemload需要完整绝对路径，常用于非标准位置的so库；接着内核的dlopen启动，启动linker
2.linker解析ELF programheader，将需要的代码段和数据映射到进程的虚拟内存空间，指定读写执行权限；
3.重定位：采用装载时重定位，由Linker集中完成所有符号的解析和修正（使用PIC选项可以使得代码可以加载到内存任意位置执行）
4.初始化，执行initarray指定的构造函数，可在dlsym找到这个so
5.JNI_OnLoad：注册native方法

关键函数：open，linker使用它打开so文件
mmap，将so映射到内存
dlsym，可以在指定库里找符号，返回地址，只有在动态注册或者首次调用时才会使用

注入：依赖注入，LD_PRELOAD，修改代码重打包，ptrace附加（dlopen），zygote Xposed添加

##### 保护校验
静态：
符号剥离  
代码混淆  
字符串加密  
加壳 
控制流平坦化
VMP

完整性校验：CRC32校验，hash校验  公钥校验 
签名校验
运行时校验：


动态：
 - 反调试
  - Ptrace
  - getppid检测父进程
  - 时间差检测
  - 针对调试器特征检测
  - 双进程
  - 异常处理






#### unidbg补环境，如何使用



#### GOT hook，inline hook
 - 全局偏移表hook，把表中地址替换，拦截关键函数调用，实现流劫持；
 - 对抗：不可写权限限制，内置hook检测写入行为，内存对比

 - 内联修改汇编指令，插入跳转指令，劫持执行流   ；  
 - 对抗：内存检测，dump内存和二进制文件进行比较； hash/完整性检测  ；代码签名；堆栈保护


#### 群控，反爬虫，风控设计

群控实现：
控制端，服务器端，被控端

客户端和设备，大量注册，分组，管理
完成安全环境检测的绕过，人机检测的绕过，身份认证
下发任务脚本，采集执行结果
支持并发控制，任务调度



群控网络层：异常IP/通信  流量特征检测  证书检测

群控应用层：
新增或可疑进程，未知服务启动，非法加载的dex，apk，so，
1.用户行为建模，延迟型处罚：
###### 服务端：
- 会话时长
- 操作路径
- 点击/滑动行为
- 输入特征
- 多台设备相同行为
- 人机验证
设备指纹分析，IP地址分析，行为分析，关联分析

###### 客户端：
应用加固和防护：
反注入，反调试，完整性检测（静态文件和动态内存），反自动化，动态挑战，传感器签名

风控场景：
1.设备风险和检测
- 模拟器
	- 客户端采集系统属性
	- 检测设备行为，缺少传感器，传感器数值异常
	- 硬件特征异常，CPU，内存，分辨率和常见机型不同
	- 驱动和进程，qemu或者ADB
	- 时机特征，应用启动时间
	- MAC/厂商信息
	- 摄像头
- 云手机
	- 网络特征，集中IP段
	- 同样的时间启动，注册
	- 设备行为，设备极度相似

- ROOT和定制机
	- 系统属性，root检测
	- SElinux状态

2.框架风险和检测
- 注入框架
	- Frida/Xposed特征检测
- 调试框架
	- gdb AS
- 多开框架
	- 虚拟空间，沙箱
- 自动化框架
	- 反爬虫，点击间隔，事件序列缺少人类噪声，人机挑战
- 群控框架
	- 高并发行为，同步行为/IP段相似
3.网络风险和检测
- 代理IP和IP池
	- 检测IP归属
	- 多账号同IP异常
	- HTTP header异常
- VPN
	- 检测IP所属的是不是VPN提供商
	- 地理位置跳跃
	- 判定IP和设备历史是否匹配
- 秒拨




#### 黑产
恶意大量注册
刷单，刷量
诈骗
盗号
数据窃取
#### 计算机网络，tcp/ip 
tcp三次握手四次挥手：需要三次是因为担心服务器接收到已失效请求
 - SYN=1
 - SYN=1-ACK=1
 - ACK=1
挥手：全双工的，所以每个方向都需要确定关闭
 - FIN=1
 - ACK=1
 - FIN=1
 - ACK=1
UDP无连接特性：（用户数据报协议
- 延迟低，速度快，不保证数据顺序，结构简单

ARP与ICMP
 - ARP负责完成从IP到MAC的转换，广播询问IP地址是谁的
 - ICMP用于在IP主机和路由器之间传递控制信息，网络是否通畅，路由是否可用 ping traceroute

TCP可靠性保障：（传输控制协议
 - 流量控制，滑动窗口实现
 - 拥塞控制：慢启动，拥塞避免，快重传，快恢复

DNS：
 - 本地缓存
 - 递归查询
 - 迭代查询 根-顶级-权威域名-本地DNS-得到ip
 - 返回结果


#### activity生命周期
- attachBaseContext

- onCreate
- onStart
- onResume
- onPause
- onStop
- onDestroy

- onRestart



#### Binder通信机制：
系统服务调用；应用内不同进程数据共享；
跨应用数据共享；自定义远程服务；
主要用于app需要系统服务；

一种跨进程通信的方式

Binder驱动运行在内核空间，复杂交换过程

数据在内核进行缓存，交换

ServiceManager：注册查询系统服务//作为一个数据的路由





#### 算法特征：
分组密码：
- tea  32轮 64bit 常量0x9E3779B9 累加或者递减   位移异或累加

|   |
|---|
|`(v0 += ((v1<<4)+k0) ^ (v1+sum) ^ ((v1>>5)+k1))`|
- xtea 类似，但改进了key的索引逻辑
- xxtea：`(p & 3) ^ e` + `(sum >> 2) & 3`



- aes ： 10到14轮   16字节区块 Sbox 查表操作  

- des：16轮 8字节 左右分组  sbox查表，大量位移，掩码

- sm4：32轮循环  固定常量FK CK  sbox

流密码：
- rc4  256字节数组   mod256   字节交换


公钥密码：
- 


侧信道攻击：物理效应，时间差，控制流，CPU状态

#### CTF
d3piano

模拟钢琴的app，按键传入整数，通过索引打乱传入整数的顺序，然后check
进行rsa加密检查是否正确
最后出来一个fakeflag
看别的lib

initarray可疑函数 初始化三个信号量  创建了四个线程 每个线程执行不同的函数

通过线程名称来检测是否处于调试或者hook状态，
根据hash获取到另一个库的对应的lib基址，得到函数地址，调用两个虚表函数，进行hook修改


alicepuzzle

多进程守护，ptrace双向检测
父进程通过 `fork()` 生成子进程，子进程复制父进程的内存和上下文。

父进程检测ptrace返回的状态码，如果检测到SIGTRAP调试信号，就进行SMC，程序自修改，进行混淆

不落地加载，

被调试的子进程，创建了一个匿名内存文件，读取rdata数据，动态加载一个elf文件，

子进程发送信号，父进程处理信号，进行内存篡改，传递输入，smc修改解密elf文件

获得真正的解密函数

.hap
查看manifest，ablility和包含的二进制
ark方舟编译器，方舟运行时
HDC
abc文件

手势锁
nativehook检测
xxtea解密，key 硬编码
原始图片-SM4魔改-base64-enc文件
上传图片，显示flag


#### LLVM PASS
加载pass流程：
- 插件加载，opt加载libpass.so的llvmGetPassPluginInfo
- 导出的llvmGetPassPluginInfo应当返回一个结构体，告诉opt注册信息
- 结构体的lambda回调注册pass到PassBuilder
- 当PassManager执行函数时，run方法被调用

pass编写流程：
- 创建Pass类，明确继承自什么类型pass
- 定义分析结构类型（如果是分析型）
- 实现Pass功能
- 插件注册




在 LLVM 中，不同类型的 Pass 需要继承不同的模板基类。下面这个表格清晰地展示了各种 Pass 类型及其对应的继承模板和核心方法：

|Pass 类型|继承模板|作用范围|核心方法|适用场景|
|---|---|---|---|---|
|​**Module Pass**​|`PassInfoMixin<YourPassName>`|整个模块（所有函数和全局变量）|`run(Module&, ModuleAnalysisManager&)`|跨函数优化、全局死代码消除、过程间分析|
|​**Function Pass**​|`PassInfoMixin<YourPassName>`|单个函数|`run(Function&, FunctionAnalysisManager&)`|局部优化、指令合并、函数内分析|
|​**Loop Pass**​|`PassInfoMixin<YourPassName>`|函数内的单个循环|`run(Loop&, LoopAnalysisManager&)`|循环展开、循环不变代码外提|
|​**CallGraphSCC Pass**​|`PassInfoMixin<YourPassName>`|调用图的强连通分量（SCC）|`run(CallGraphSCC&, CallGraphSCCAnalysisManager&)`|函数内联、过程间优化|
|​**Analysis Pass**​|`AnalysisInfoMixin<YourAnalysisName>`|任意（由具体分析决定）|`run(IRUnit&, AnalysisManager&)`|




Pass混淆：
MBA混淆：混合布尔运算
FLA 控制流平坦化
BCF 虚假控制流插入
DBB 基本块复制
常量加密解密


Pass流程：
Module：Func：Block：指令类型：Instruction
指令类型：BinaryOperator，LoadInst，CallInst，BranchInst，CmpInst

二进制转IR：
MC-Sema
RetDec

CFG：操作BasicBlock和它们之间的终结指令，归结为新增/删除/克隆/拆分/合并 或者修改block的terminator

CFG混淆：
1.控制流平坦化：提取基本块，新建dispatcher块，用switch控制逻辑跳转，每个块最后返回dispatcher
2.伪控制流插入：插入不会执行的假分支
3.把直接的跳转：换成复杂的计算跳转，或者包装成异常处理



#### 爬虫

 常用技术栈与工具

- **轻量请求 + 解析**：`requests` + `BeautifulSoup` / `lxml`（Python）
    
- **异步高并发**：`aiohttp` / `httpx` + `asyncio`；Node 用 `node-fetch` / `axios` + `puppeteer`
    
- **爬虫框架**：Scrapy（包含调度、去重、下载中间件、Pipeline）
    
- **动态页面渲染**（JS 渲染）：Selenium / Playwright / Puppeteer（无头浏览器）
    
- **反反爬工具**：自动 cookie 管理、浏览器自动化（仅用于合法测试）
    
- **数据存储**：关系库（Postgres/MySQL）、NoSQL（MongoDB）、列式/搜索（Elasticsearch）或文件（CSV/JSON/Parquet）
    
- **代理/分布式**：代理池、分布式调度（Kafka/Redis + Celery/RQ）、分布式爬虫（Franz Kafka + 多 worker）

 常见检测信号（Indicators）

- **请求速率/并发**：单位时间内的请求数异常高。
    
- **IP 行为特征**：单 IP 发大量请求、IP 池频繁切换、IP 与地理位置不一致、同一子网出现大量请求。
    
- **User-Agent / Header 指纹**：缺少常见 header、UA 异常或格式化错误；header 频繁变换。
    
- **Cookies / Session 行为**：无法正确处理 cookies、session inconsistency、没有 referer。
    
- **页面行为**：不执行 JS（未加载资源）、不加载相关图片/资源、缺少鼠标/键盘交互（对需要交互的网站）。
    
- **访问路径模式**：深层次高速爬取、总是先访问 API 接口而非首页。
    
- **内容相似度 / 重复**：大量相似请求或请求结果高度重复。
    
- **指纹/设备信息**：浏览器指纹、TLS 指纹、TCP/IP 指纹与正常用户群体分布不一致。
    
- **异常响应处理**：访问时始终带特定 cookie/参数或绕过前端加密逻辑。
    

常见反爬手段（Site-side defenses）

- **速率限制（Rate limiting）**：按 IP 或 token 限制请求速率。
    
- **IP 黑白名单 & 阻断代理**：识别并封禁代理/数据中心 IP 段；对可疑 IP 加强验证。
    
- **WAF（Web Application Firewall）**：拦截常见爬虫模式、注入攻击、爬取签名。
    
- **验证码 / 挑战**：图形或行为验证码（image CAPTCHA、滑动验证码、多因素挑战）。
    
- **JS 复杂化 & 动态 Token**：页面在客户端运行 JS 生成动态签名或 token（例如每次请求需带 ephemeral token），增加模拟成本。
    
- **浏览器指纹与 TLS 指纹检测**：检测浏览器插件/指纹差异；检测非标准 TLS 握手。
    
- **行为分析/ML 检测**：训练模型识别正常用户与机器的行为差异（点击/停留/滚动等）。
    
- **蜜罐/隐蔽链接**：页面内放置对普通用户不可见但爬虫会请求的“蜜罐”链接，访问这些链接表明非正常抓取。
    
- **动态内容/加密接口**：关键数据通过加密、混淆、或仅在交互完成后才返回。
    
- **服务端态度**：限制 API 访问频次、对异常请求返回验证码或 403/429。