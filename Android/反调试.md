

#### 更深入的线程检测：
pthread_create:线程创建

线程的启动流程：pthread_create  -》 clone -》 新线程 -》 __start_thread -》__pthread_start

startthread是新线程入口，初始化线程环境，调用pthreadstart
pthreadstart最终在新线程环境中执行用户传入的函数

在pthreadstart截取
```js
function hook_start_thread() {
    var libc = Process.findModuleByName("libc.so");
    var addr_start_thread = libc.base.add(0xCB5D8); // __pthread_start 偏移
    var original_start_thread = new NativeFunction(addr_start_thread, "void", ["pointer"]);

    Interceptor.replace(addr_start_thread, new NativeCallback(function (thread) {
        var user_func_addr = thread.add(0x60).readPointer();
        var nice_addr = addr2nice(user_func_addr);

        console.log("thread start: " + nice_addr);

        if (nice_addr.includes("libfrida.so")) { 
            // 检查是否为 Frida 或其他恶意模块创建的线程
            console.log("frida check thread detected");
        } else {
            // 正常线程继续执行
            original_start_thread(thread);
        }
    }, "void", ["pointer"]));
}
hook_start_thread();
```



#/proc/self/status
TracePid字段表示调试进程的PID，非0，则表示在调试
#/proc/self/maps 
该文件包含内存映射信息，如果发现有调试器相关的内存映射，说明进程正在被调试