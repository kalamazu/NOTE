(https://bbs.kanxue.com/thread-280609.htm)
(https://aar0n3906.github.io/2024/08/13/%E5%AF%B9%E6%9F%90%E6%95%B0%E5%AD%97%E5%A3%B3app%E7%9A%84%E5%88%86%E6%9E%90/)
(https://github.com/oacia/stalker_trace_so/blob/main/stalker_trace_so.py)
### stubapp:
 - 静态函数初始化stub类，配置静态变量
 - 重写attachBaseContext
 - proguard混淆，字符串混淆
 - 加载libjiagu.so

 #attachBaseContext
 常重写用于安全加固，配置语言环境，框架需要hook时

### libjiagu.so
- 发现so失去导出表，dump一个有导出表的
- hook dlopen 和open 分析程序打开的so库和打开的文件有哪些
- 发现打开/proc/self/maps进行反调试

对抗：替换一个正常的maps
结果：壳尝试访问maps文件中的地址，发生错误，因为maps文件是静态替换的
解决：换一个不存在的文件即可

过掉map反调试可以获得三个加密过的dex，但还没有解密就退出了，可能还有别的反调试。继续通过dlopen寻找更晚的hook点

再dump一个装载了dex 的so文件

接着发现了so里面还有一个ELF，猜测为壳ELF加载主ELF

dump主ELF

主ELF加密过

### 主ELF
#so壳
壳ELF由系统linker加载，保护，解密主ELF
ProgramHeader是ELF文件头部的一部分，告诉loader如何加载每个segment

壳ELF通过RC4，base64等多种编码加密，解密主ELF
主ELF再RC4，uncompress解密DEX

#### 反调试
TracerPid检测：检查/proc/self/status中的TracerPid字段
readlink检测：检查/proc/self/exe或文件描述符/proc/self/fd/的链接目标，判断是否指向了调试器相关路径（/data/local/tmp）
strstr检测：读取/maps中搜索特定管检测，判断是否存在调试环境
dbus检测：检测系统是否存在frida等工具的dbus通信


pthread_create反调试：创建一个独立的监控线程


#ffi_call 
动态调用函数


